\section{Zapewnienie spójności danych}

\begin{frame}{Spójność danych}
	
	Szalenie ważne jest, abyśmy mogli stwierdzić z dużą dozą pewności, że dane po stronie odbiorcy i nadawcy są dokładnie takie same.
	
	Chcielibyśmy móc to sprawdzić przesyłając znacząco mniej danych niż same dane.
	
	Do tego celu fenomenalnie nadają się kryptograficzne funkcje hashujące.

\end{frame}

\begin{frame}{Kryptograficzne funkcje haszujące}
	
	Kryptograficzna funkcja haszująca dla danych bajtów wejściowych zwraca stosunkowo dużą liczbę, typowo 128--512 bitów.
	
	Musi mieć tę własność, że najdrobniejsza zmiana danych wejściowych --- np. flipnięcie 1 bitu wśród 100 GiB --- całkowicie zmienia wyjście tej funkcji.
	
	Równie ważna własność --- dla danej wartości funkcji jest niesłychanie trudno spreparować generujące ją wejście.
	
	Teraz: jeśli odbiorca i nadawca porównają kryptograficzny skrót ze swych kopii danych, i jeśli skróty te będą takie same, z dość dużym prawdopodobieństwem dane są identyczne.
	
\end{frame}

\begin{frame}{Prawdopodobieństwo kolizji dla 128-bitowej funkcji}
	
	W poprzednim slajdzie mówimy o dużym prawdopodobieństwie.
	
	Prawdopodobieństwo kolizji dla dwóch hashy przy 128-bitowej zwracanej liczbie to $\frac{1}{2^{128}}=\frac{1}{340282366920938463463374607431768211456}$.
	
	Jeśli jednak weźmiemy pod uwagę \href{http://en.wikipedia.org/wiki/Birthday_problem}{paradoks urodzin}, możemy uzyskać prawdopodobieństwo kolizji $\frac{1}{2}$ wśród $2^{64}$ takich haszy.
	
	... czyli np. haszując 6 miliardów plików na sekundę przez następne 100 lat, któreś dwa będą kolidować z prawdopodobieństwem $\frac{1}{2}$. :-)
	
\end{frame}

\begin{frame}{MD5}
	Badziewie.
	
	Da się obejść.
\end{frame}

\begin{frame}{SHA-n}
	
	To można rozbić na poszczególne wersje: SHA-0, SHA-1, itd.
\end{frame}


\begin{frame}{Podpis cyfrowy}
	
\end{frame}

\begin{frame}{Algorytmy podpisów cyforwych}
	
\end{frame}